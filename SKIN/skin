#!/usr/bin/env python3
import os
import re
import sys
import time
import shutil
import random
import hashlib
import subprocess
import requests
import base64
from pathlib import Path
from concurrent.futures import ThreadPoolExecutor

from rich.console import Console
from rich.prompt import Prompt
from rich.panel import Panel
from rich.progress import Progress, SpinnerColumn, BarColumn, TextColumn
from rich.live import Live
from rich.table import Table
from rich.align import Align
from rich.text import Text
from rich import box

console = Console()

# ───── CONFIG ────────────────────────────────────────────────────────────────
MAGIC_NUMBER = b'\x28\xB5\x2F\xFD'
DICT_START_HEX = bytes.fromhex("37 A4 30 EC")
MAX_COMPRESSION_LEVEL = 22
MAX_WORKERS = os.cpu_count() or 4
TARGET_SIZE = 65536

# ───── DIRECTORY CONFIG ──────────────────────────────────────────────────────
BASE_MOD_DIR = os.getcwd()
GAME_DIRS = {"BGMI": os.path.join(BASE_MOD_DIR, "BGMI")}
OUTPUT_DIR_NAME = "output"
edited_dat_DIR_NAME = "edited_dat"
REPACKED_DIR_NAME = "repack_pak"
MODSKIN_TXT = "modskin.txt"
NULL_TXT = "null.txt"
CHANGELOG_TXT = "changelog.txt"
NULLED_LOG_TXT = "nulled.txt"
LOGO_FILE = "logo.txt"


# ───── HELPER FUNCTIONS ──────────────────────────────────────────────────────
def parse_id_pairs(txt_path):
    """Parse ID pairs from modskin.txt supporting both comma and space separation."""
    pairs = []
    with open(txt_path, encoding="utf-8") as f:
        for line_num, line in enumerate(f, 1):
            line = line.strip()
            if not line or line.startswith('#'):
                continue
            
            # Try comma separation first
            if ',' in line:
                parts = line.split(',', 1)
                if len(parts) == 2:
                    a, b = parts[0].strip(), parts[1].strip()
                    if a and b:
                        pairs.append((a, b))
                        continue
            
            # Try space separation
            parts = line.split()
            if len(parts) == 2:
                a, b = parts[0].strip(), parts[1].strip()
                if a and b:
                    pairs.append((a, b))
                    continue
            
            console.print(f"[yellow]⚠ Skipping invalid line {line_num}: {line}[/]")
    
    return pairs

# ───── EXTERNAL TOOL FUNCTIONS ──────────────────────────────────────────────

def run_pak_tool_repack(game_base_dir):
    """
    Runs sequential steps:
      1) python hr repack
      2) python hit (in Termux home ~/SKIN/)
      3) python mini repack (in BGMI/hit/) then copy Repacked/* -> BGMI/repack_pak/
      4) python hr repack-obb
    """
    import os, sys, time, threading, subprocess, shutil

    python_exec = sys.executable

    # Locate hr script
    hr_script = None
    for fn in ["hr", "hr.py"]:
        candidate = os.path.join(game_base_dir, fn)
        if os.path.isfile(candidate):
            hr_script = candidate
            break
    if not hr_script:
        print("HR repack script not found in game directory.")
        return False

    # Load actual filenames from edited_dat directory
    edited_dir = os.path.expanduser("~/SKIN/BGMI/edited_dat")
    file_list = sorted(os.listdir(edited_dir))
    file_list = [f for f in file_list if f.lower().endswith(".dat")]

    def run_with_short_logs(cmd_args, cwd, simplify=False):
        proc = subprocess.Popen(
            [python_exec] + cmd_args,
            cwd=cwd,
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            universal_newlines=True,
            bufsize=1
        )

        counts = {"success": 0, "fail": 0, "total": 0}
        current_index = -1

        def reader():
            nonlocal current_index
            for raw_line in proc.stdout:
                line = raw_line.strip()
                if not line:
                    continue
                if simplify:
                    if line.startswith("Repacking DAT"):
                        counts["total"] += 1
                        current_index = counts["total"] - 1
                    elif "✓ repacked" in line:
                        counts["success"] += 1
                        if 0 <= current_index < len(file_list):
                            print(f"[OK] {file_list[current_index]}")
                        current_index = -1
                    elif "✗" in line and "too large" not in line:
                        counts["fail"] += 1
                        if 0 <= current_index < len(file_list):
                            print(f"[FAIL] {file_list[current_index]}")
                        current_index = -1
                else:
                    print(line)

        t = threading.Thread(target=reader, daemon=True)
        t.start()

        while proc.poll() is None:
            try:
                proc.stdin.write("\n")
                proc.stdin.flush()
            except Exception:
                pass
            time.sleep(1)

        t.join(timeout=2)
        return counts, proc.returncode

    # Step 1: HR repack
    print(f"Running HR repack: {hr_script} repack")
    counts, rc1 = run_with_short_logs([hr_script, "repack"], cwd=game_base_dir, simplify=True)
    print(f"OK={counts['success']}, FAIL={counts['fail']}, TOTAL={counts['total']}")

    # Step 2: python hit (in Termux home)
    hit_dir = os.path.expanduser("~/SKIN")
    print(f"Running python hit in {hit_dir}")
    rc_hit = subprocess.call([python_exec, "hit"], cwd=hit_dir)

    # Step 3: python mini repack in BGMI/hit/ then copy files
    mini_dir = os.path.expanduser("~/SKIN/BGMI/hit")
    re_pack_dir = os.path.join(mini_dir, "Repacked")
    final_dir = os.path.expanduser("~/SKIN/BGMI/repack_pak")
    os.makedirs(final_dir, exist_ok=True)

    print(f"Running python mini repack in {mini_dir}")
    rc_mini = subprocess.call([python_exec, "mini", "repack"], cwd=mini_dir)

    # Copy files from Repacked -> repack_pak
    if os.path.isdir(re_pack_dir):
        for f in os.listdir(re_pack_dir):
            src = os.path.join(re_pack_dir, f)
            dst = os.path.join(final_dir, f)
            shutil.copy2(src, dst)
            print(f"[COPIED] {f}")

    # Step 4: HR repack-obb
    print(f"Running HR repack-obb: {hr_script} repack-obb")
    _, rc2 = run_with_short_logs([hr_script, "repack-obb"], cwd=game_base_dir, simplify=False)

    return rc1 == 0 and rc_hit == 0 and rc_mini == 0 and rc2 == 0







        
# ───── CORE LOGIC FUNCTIONS ──────────────────────────────────────────────────

def build_safe_pattern(ascii_id: bytes):
    return re.compile(rb"(?<![0-9])" + re.escape(ascii_id) + rb"(?![0-9])")

def pad_pattern(src: bytes, target_len: int) -> bytes:
    cur = bytearray(src)
    to_insert = target_len - len(cur)
    idx = cur.find(0x00)
    if idx < 0:
        cur.extend(b'\x00' * to_insert)
    else:
        for _ in range(to_insert):
            cur.insert(idx, 0x00)
    return bytes(cur)

def truncate_pattern(src: bytes, target_len: int) -> bytes:
    cur = bytearray(src)
    to_remove = len(cur) - target_len
    while to_remove > 0:
        idx = cur.find(0x00)
        if idx < 0:
            break
        del cur[idx]
        to_remove -= 1
    if to_remove > 0:
        del cur[-to_remove:]
    return bytes(cur)

def mod_skin_flow(game: str):
   #print("🚀 Mod Skin  Initialized")
    game_base_dir = GAME_DIRS[game]
    txt_path = os.path.join(BASE_MOD_DIR, MODSKIN_TXT)
    output_dir = os.path.join(game_base_dir, OUTPUT_DIR_NAME)
    edited_dat_dir = os.path.join(game_base_dir, edited_dat_DIR_NAME)
    changelog_path = os.path.join(BASE_MOD_DIR, CHANGELOG_TXT)

    if not os.path.isfile(txt_path):
        print(f"✖ {MODSKIN_TXT} missing")
        time.sleep(2)
        return False

    #print("Finding ID pairs...")
    pairs = parse_id_pairs(txt_path)
    if not pairs:
        print(f"⚠ No valid ID pairs found in {MODSKIN_TXT}")
        print("Format: Use either 'ID1,ID2' or 'ID1 ID2' per line")
        time.sleep(2)
        return False
    print(f"Found {len(pairs)} ID pairs.")

    all_files = []
    if not os.path.isdir(output_dir):
        print(f"✖ Output directory not found: {output_dir}")
        time.sleep(2)
        return False

    for fn in os.listdir(output_dir):
        path = os.path.join(output_dir, fn)
        if os.path.isfile(path):
            all_files.append(path)
    print(f"Found {len(all_files)} files to process.")

    if not all_files:
        return False

    cache = {p: open(p, 'rb').read() for p in all_files}
    longhex_map = {}

    #print("Building longhex map...")
    for id1, id2 in pairs:
        a1, a2 = id1.encode(), id2.encode()
        p1, p2 = build_safe_pattern(a1), build_safe_pattern(a2)
        pos1, pos2, d1, d2 = None, None, b"", b""
        for data in cache.values():
            if pos1 is None and (m := p1.search(data)):
                pos1, d1 = m.start(), data
            if pos2 is None and (m := p2.search(data)):
                pos2, d2 = m.start(), data
            if pos1 is not None and pos2 is not None:
                break
        if pos1 is None or pos2 is None:
            continue
        lh1 = a1 + d1[pos1 + len(a1):pos1 + len(a1) + 5]
        lh2 = a2 + d2[pos2 + len(a2):pos2 + len(a2) + 5]
        if len(lh1) == len(lh2):
            swaps = [(lh1, lh2), (lh2, lh1)]
        elif len(lh1) > len(lh2):
            swaps = [(lh1, pad_pattern(lh2, len(lh1))), (lh2, truncate_pattern(lh1, len(lh2)))]
        else:
            swaps = [(lh2, pad_pattern(lh1, len(lh2))), (lh1, truncate_pattern(lh2, len(lh1)))]
        longhex_map[(id1, id2)] = swaps

    if not longhex_map:
        print("⚠ No longhex pairs could be found.")
        time.sleep(2)
        return False

    patterns = [re.compile(rb"(?<![0-9])" + re.escape(src) + rb"(?![0-9])") for swaps in longhex_map.values() for src, _ in swaps]
    valid_files = [p for p, data in cache.items() if any(rx.search(data) for rx in patterns)]

    if not valid_files:
        print("⚠ No files contain specified patterns.")
        time.sleep(2)
        return False

    if os.path.isdir(edited_dat_dir):
        shutil.rmtree(edited_dat_dir)
    os.makedirs(edited_dat_dir, exist_ok=True)

    print(f"{len(valid_files)} files → edited_dat")

    for src in sorted(valid_files):
        shutil.copy2(src, edited_dat_dir)

    changelog = {pair: [] for pair in longhex_map}
    changelog_simple = []

    for src in sorted(valid_files):
        filename = os.path.basename(src)
        print(f"[OK] {filename}...")

        edited_dat_path = os.path.join(edited_dat_dir, filename)
        orig = open(edited_dat_path, 'rb').read()
        new = bytearray(orig)

        for pair, swaps in longhex_map.items():
            ops = []
            for src_pat, dst_pat in swaps:
                rx = re.compile(rb"(?<![0-9])" + re.escape(src_pat) + rb"(?![0-9])")
                matches = list(rx.finditer(orig))
                if not matches:
                    continue
                for m in matches:
                    new[m.start():m.start() + len(src_pat)] = dst_pat
                    changelog_simple.append((filename, pair, src_pat.hex(), dst_pat.hex()))
                ops.append((src_pat.hex(), dst_pat.hex(), len(matches)))
            if ops:
                changelog[pair].append((filename, ops))

        if new != orig:
            with open(edited_dat_path, 'wb') as f:
                f.write(new)
        time.sleep(0.05)

    with open(changelog_path, 'w', encoding='utf-8') as f:
        for filename, pair, frm, to in changelog_simple:
            f.write(f"ID PAIR : {pair[0]} {pair[1]}\n")
            f.write(f"FILE : {filename}\n")
            f.write(f"CHANGES : APPLIED LONGHEX {frm} -> {to}\n")
            f.write("\n")

    #print("📝 Mod Skin Complete")
    return True
    
def size_fix_flow(game: str, max_nulls_per_file: int = 50):
    game_base_dir = GAME_DIRS[game]
    edited_dat_dir = os.path.join(game_base_dir, edited_dat_DIR_NAME)
    null_path = os.path.join(BASE_MOD_DIR, NULL_TXT)
    modskin_path = os.path.join(BASE_MOD_DIR, MODSKIN_TXT)
    nulled_log_path = os.path.join(edited_dat_dir, NULLED_LOG_TXT)

    if not os.path.isdir(edited_dat_dir):
        print(f"✖ edited_dat directory not found: {edited_dat_dir}")
        return False

    files_to_process = [
        fn for fn in sorted(os.listdir(edited_dat_dir))
        if os.path.isfile(os.path.join(edited_dat_dir, fn)) and not fn.endswith('.txt')
    ]
    if not files_to_process:
        print("✖ No files found in edited_dat folder.")
        return False

    # Auto-calculate total nulls
    total_nulls = len(files_to_process) * max_nulls_per_file
    print(f"{len(files_to_process)} files found.")
    print(f"Applying {max_nulls_per_file} nulls per file → total {total_nulls} nulls will be applied.")

    # Read modskin IDs
    mod_ids = set()
    if os.path.isfile(modskin_path):
        pairs = parse_id_pairs(modskin_path)
        for a, b in pairs:
            if a.isdigit():
                mod_ids.add(a)
            if b.isdigit():
                mod_ids.add(b)

    # Read null IDs
    master_null_ids = []
    if os.path.isfile(null_path):
        with open(null_path, encoding='utf-8') as nf:
            for line in nf:
                m = re.search(r'\bID\s+(\d+)\b', line) or re.search(r'(\d{3,})', line)
                if m:
                    master_null_ids.append(m.group(1).encode())

    seen = set()
    unique_master_ids = [x for x in master_null_ids if not (x in seen or seen.add(x))]
    null_ids = [nid for nid in unique_master_ids if not (nid.decode().startswith('40') or nid.decode() in mod_ids)]

    #print(f"Found {len(null_ids)} unique IDs to null.")

    nulled_info = {}

    for fn in files_to_process:
        print(f"[OK] {fn}...")
        file_path = os.path.join(edited_dat_dir, fn)
        orig_bytes = open(file_path, 'rb').read()
        data = bytearray(orig_bytes)
        nulled_info[fn] = []
        nulls = 0
        matches = []

        for id_bytes in null_ids:
            start_search = 0
            while (pos := data.find(id_bytes, start_search)) >= 0:
                matches.append((pos, id_bytes))
                start_search = pos + 1
        matches.sort(key=lambda x: x[0], reverse=True)

        # Apply max_nulls_per_file
        for pos, id_bytes in matches:
            if nulls >= max_nulls_per_file or pos + len(id_bytes) + 5 > len(data):
                continue
            before = data[pos - 1:pos] if pos > 0 else None
            after = data[pos + len(id_bytes) + 5:pos + len(id_bytes) + 6] if pos + len(id_bytes) + 5 < len(data) else None
            if (before and before in b"0123456789") or (after and after in b"0123456789"):
                continue
            pattern = orig_bytes[pos:pos + len(id_bytes) + 5]
            nulled_info[fn].append((id_bytes.decode(), pattern.hex()))
            data[pos:pos + len(id_bytes) + 5] = b'\x00' * (len(id_bytes) + 5)
            nulls += 1

        with open(file_path, 'wb') as f:
            f.write(data)
        time.sleep(0.05)

    # Write log
    with open(nulled_log_path, 'w', encoding='utf-8') as nf:
        for fn, entries in nulled_info.items():
            if not entries:
                continue
            nf.write(f"{fn}:\n")
            for id_str, hx in entries:
                if id_str in mod_ids or id_str.startswith('40'):
                    continue
                nf.write(f"  ID {id_str} → nulled longhex {hx}\n")
            nf.write("\n")

    #print("✨ Size-fix complete in edited_dat folder!")
    return True


def modskin_complete_flow():
    """Complete MODSKIN workflow: ModSkin → Size Fix → External pak_tool repack"""
    #print("🚀 MODSKIN Complete Workflow Started")

    if not mod_skin_flow("BGMI"):
        print("✖ Mod Skin failed, aborting workflow")
        return

    print("Mod Skin Complete")
    time.sleep(1)

    # Auto-size fix: each file gets 5 nulls
    if not size_fix_flow("BGMI", max_nulls_per_file=150):
        print("✖ Size Fix failed, aborting workflow")
        return

    print("Size Fix Complete")
    time.sleep(1)

    # Run external pak_tool repack
    if not run_pak_tool_repack(GAME_DIRS["BGMI"]):
        print("✖ pak_tool repack failed, aborting workflow")
        return

    #print("🎉 MODSKIN Complete Workflow Finished Successfully!")
    #print("📁 Check BGMI/repacked/ folder for minimini_obbzsdic_obb.pak")

def zip_obb_flow():
    """ZIP OBB workflow using external repack.sh"""
    print("📦 ZIP OBB Workflow Started")

    if not run_repack_sh():
        print("✖ ZIP OBB workflow failed")
        return

    print("🎉 ZIP OBB Workflow Completed Successfully!")

# ───── MAIN MENU ─────────────────────────────────────────────────────────────
#!/usr/bin/env python3  
import os  
import sys  
import time  
import shutil  
import traceback  
from pathlib import Path  
from rich.console import Console  
from rich.panel import Panel  
from rich.prompt import Prompt  
from rich.table import Table  
from rich.align import Align  

console = Console()

# ───── MAIN MENU ─────────────────────────────────────────────────────────────  
import os
import sys
from rich.console import Console
from rich.panel import Panel

console = Console()

# ---------------- Commands Dictionary ----------------
COMMANDS = {}

def register_command(name, description, func):
    """Register a new command."""
    COMMANDS[name] = {
        "description": description,
        "func": func
    }

# ---------------- Utility Functions ----------------
def clear_screen():
    os.system('cls' if os.name == 'nt' else 'clear')

def show_help():
    console.print(Panel("Available commands", style="bold cyan"))
    for cmd, info in COMMANDS.items():
        console.print(f"[green]{cmd}[/]: {info['description']}")

# ---------------- Command Functions ----------------
def modskin_command():
    modskin_complete_flow()

def zipobb_command():
    zip_obb_flow()

def exit_command():
    console.print("\nGoodbye!", style="bold red")
    exit(0)

def help_command():
    show_help()

# ---------------- Register Commands ----------------
register_command("/modskin", "Run Mod Skin workflow", modskin_command)
register_command("/zipobb", "Run ZIP OBB workflow", zipobb_command)
register_command("/exit", "Exit the program", exit_command)
register_command("/help", "Show this help message", help_command)

# ---------------- Main Interface ----------------
def manual_mode():
    """Command-based manual interface."""
    while True:
        try:
            clear_screen()
            console.print(Panel("Modding Tool", style="bold blue"))
            show_help()

            user_input = console.input("\n[bold yellow]Enter command[/]: ").strip().lower()

            if user_input in COMMANDS:
                COMMANDS[user_input]["func"]()
            else:
                console.print(f"[red]Invalid command:[/] {user_input}")
                console.print("Type /help to see available commands.")

            input("\nPress Enter to continue...")
        except (KeyboardInterrupt, EOFError):
            console.print("\nProgram interrupted. Exiting.", style="bold red")
            break
        except Exception as e:
            console.print(f"\n[red]An unexpected error occurred:[/]\n{e}", style="bold red")

def direct_mode(cmd_name: str):
    """Run a single command directly from sys.argv."""
    cmd_name = "/" + cmd_name.lower() if not cmd_name.startswith("/") else cmd_name.lower()
    if cmd_name in COMMANDS:
        console.print(f"Running command: {cmd_name}", style="bold green")
        COMMANDS[cmd_name]["func"]()
    else:
        console.print(f"[red]Invalid direct command:[/] {cmd_name}")
        console.print("Available direct commands:")
        for cmd in COMMANDS:
            console.print(f" {cmd}")

# ---------------- Entry Point ----------------
if __name__ == "__main__":
    if len(sys.argv) > 1:
        # Direct run mode: python z3.py modskin
        direct_mode(sys.argv[1])
    else:
        # Manual interactive mode: python z3.py
        manual_mode()